// Generated by CoffeeScript 2.3.2
(function() {
  // ENUMS          
  // This is where the enum-like objects
  // are defined
  var abbrev_and_word, find_item_issues, find_items, find_items_in_line, highlight_issues, highlight_line, is_alphanumeric, itemIssues, itemTypes, multiple_abbrevs, queep, str_to_char_dict, tag_issue,
    indexOf = [].indexOf;

  itemTypes = {
    abbrev: 'abbreviation',
    word: 'word'
  };

  itemIssues = {
    multipleAbbrevs: 'multiple abbreviations',
    abbrevAndWord: 'abbreviation and word'
  };

  // END ENUMS

  // BEGIN item issue functions
  // this group of functions looks at an item
  // and returns true if it has a particular error
  // and false otherwise, optionally also returns some item details
  str_to_char_dict = function() {
    return arguments;
  };

  multiple_abbrevs = function(item_to_check, item) {
    if (item === item_to_check) {
      // this is the one we're checking!
      return false;
    }
    if (item['hash'] === item_to_check['hash'] && item['word'] !== item_to_check['word'] && item['type'] === itemTypes.abbrev && item_to_check['type'] === itemTypes.abbrev) {
      return true;
    }
    return false;
  };

  abbrev_and_word = function(item_to_check, item) {
    if (item === item_to_check) {
      // this is the one we're checking!
      return false;
    }
    if (item['hash'] === item_to_check['hash'] && item['word'] !== item_to_check['word'] && ((item['type'] === itemTypes.abbrev && item_to_check['type'] === itemTypes.word) || (item['type'] === itemTypes.word && item_to_check['type'] === itemTypes.abbrev))) {
      return true;
    }
    return false;
  };

  // END item issue functions
  tag_issue = function(item) {
    var ref, ref1;
    if (ref = itemIssues.multipleAbbrevs, indexOf.call(item['issues'], ref) >= 0) {
      return '<span class = "dupe">' + item['word'] + '</span>';
    } else if (ref1 = itemIssues.abbrevAndWord, indexOf.call(item['issues'], ref1) >= 0) {
      return '<span class = "acro_pair">' + item['word'] + '</span>';
    } else if (item['issues'].length === 0 && item['type'] === itemTypes.word) {
      return '<span class = "just_word">' + item['word'] + '</span>';
    }
    return item['word'];
  };

  highlight_line = function(line, items, line_num) {
    var elem, highlighted_line, i, item, j, k, key, l, len, len1, line_dict, ref, ref1, ref2;
    // "spread" the line
    // basically converts it to a char array
    line_dict = str_to_char_dict(...line);
    for (j = 0, len = items.length; j < len; j++) {
      item = items[j];
      if (item['line'] === line_num) {
        for (i = k = ref = item['loc'], ref1 = item['loc'] + item['word'].length; (ref <= ref1 ? k < ref1 : k > ref1); i = ref <= ref1 ? ++k : --k) {
          delete line_dict[i];
        }
        line_dict[item['loc']] = item;
      }
    }
    highlighted_line = '';
    ref2 = Object.keys(line_dict);
    for (l = 0, len1 = ref2.length; l < len1; l++) {
      key = ref2[l];
      elem = line_dict[key];
      if (typeof elem === 'string') {
        highlighted_line += elem;
      } else {
        highlighted_line += tag_issue(elem);
      }
      console.log(highlighted_line);
    }
    return highlighted_line;
  };

  highlight_issues = function(text, items) {
    var highlighted_text, i, j, lines, ref;
    console.log(text);
    lines = text.split('\n');
    highlighted_text = '';
    for (i = j = 0, ref = lines.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
      highlighted_text += highlight_line(lines[i], items, i) + '\n';
    }
    return highlighted_text;
  };

  // finds any problems that items may have
  // which may need to be pointed out
  find_item_issues = function(items) {
    var item_to_check, j, k, len, len1, other_item, ref;
    for (j = 0, len = items.length; j < len; j++) {
      item_to_check = items[j];
      item_to_check['issues'] = [];
      for (k = 0, len1 = items.length; k < len1; k++) {
        other_item = items[k];
        if (item_to_check === other_item) {
          continue;
        }
        if (multiple_abbrevs(item_to_check, other_item)) {
          item_to_check['issues'].push(itemIssues.multipleAbbrevs);
        }
        if (abbrev_and_word(item_to_check, other_item)) {
          if (ref = itemIssues.abbrevAndWord, indexOf.call(item_to_check['issues'], ref) < 0) {
            item_to_check['issues'].push(itemIssues.abbrevAndWord);
          }
        }
      }
    }
    return items;
  };

  is_alphanumeric = function(char) {
    var code;
    code = char.charCodeAt(0);
    if (!(code > 47 && code < 58) && !(code > 64 && code < 91) && !(code > 96 && code < 123)) {
      return false;
    }
    return true;
  };

  // find just the items in one line
  find_items_in_line = function(line, max_len, items, line_num) {
    var found, i, j, k, line_loc, ref, ref1, word;
    // our max len can't be longer than the actual line is
    max_len = Math.min(max_len, line.length);
    // an empty dictionary to store our items
    found = [];
// cut every possible slice
    for (line_loc = j = 0, ref = line.length; (0 <= ref ? j < ref : j > ref); line_loc = 0 <= ref ? ++j : --j) {
      max_len = Math.min(max_len, line.length - line_loc);
      for (i = k = ref1 = max_len; (ref1 <= 0 ? k < 0 : k > 0); i = ref1 <= 0 ? ++k : --k) {
        word = line.slice(line_loc, line_loc + i);
        if (items[word] && (line_loc === 0 || !is_alphanumeric(line.slice(line_loc - 1, line_loc))) && (line_loc + i === line.length || !is_alphanumeric(line.slice(line_loc + i, line_loc + i + 1)))) {
          found.push({
            'loc': line_loc,
            'word': word,
            'line': line_num,
            'dict': items[word]['dict'],
            'type': items[word]['type'],
            'hash': items[word]['hash']
          });
        }
      }
    }
    return found;
  };

  // find all items of interest in the text
  find_items = function(text, items) {
    var found, i, j, lines, max_len, ref;
    found = [];
    // get individual lines
    lines = text.split('\n');
    // TODO: change this to the max item length, not line length
    // the max length of an item (is what it should be)
    max_len = 10;
// iterate through all the lines
    for (i = j = 0, ref = lines.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
      found = found.concat(find_items_in_line(lines[i], max_len, items, i));
    }
    return found;
  };

  queep = function() {
    var found, html, text;
    text = $('#output').html();
    found = find_items(text, {
      'training': {
        'dict': {
          'abbrevs': ['trng'],
          'words': ['training']
        },
        'type': itemTypes.word,
        'hash': 'asdfbeqr'
      },
      'trng': {
        'dict': {
          'abbrevs': ['trng'],
          'words': ['training']
        },
        'type': itemTypes.abbrev,
        'hash': 'asdfbeqr'
      },
      'msn': {
        'dict': {
          'abbrevs': ['msn', 'misn'],
          'words': ['mission']
        },
        'type': itemTypes.abbrev,
        'hash': 'mmmm'
      },
      'misn': {
        'dict': {
          'abbrevs': ['msn', 'misn'],
          'words': ['mission']
        },
        'type': itemTypes.abbrev,
        'hash': 'mmmm'
      },
      '&amp;': {
        'dict': {
          'abbrevs': ['&amp'],
          'words': ['and']
        },
        'type': itemTypes.abbrev,
        'hash': 'zzzzz'
      },
      'and': {
        'dict': {
          'abbrevs': ['&amp;'],
          'words': ['and']
        },
        'type': itemTypes.word,
        'hash': 'zzzzz'
      }
    });
    console.log(find_item_issues(found));
    html = highlight_issues(text, found);
    return {
      // result = highlight_word_acro_pairs(text_content,word_acro_data)
      'html': html,
      'issues': found // returning: {'html': text_content, 'tooltipped_words':[]}
    };
  };

  $(function() {
    return $("#input").on("input propertychange paste", function() {
      var result;
      //Adds the text you type in, to the output. 
      $('#output').text($('#input').val());
      console.log("***********BEGIN TO QUEEP*************");
      result = queep();
      console.log("***********CEASE TO QUEEP*************");
      $('#output').html(result['html']);
    });
  });

  // add_tooltips(result['tooltipped_words'])
// add_tooltip_custom(".acro_green", "Approved abbreviation")

}).call(this);
